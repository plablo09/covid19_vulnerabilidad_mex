# AUTOGENERATED! DO NOT EDIT! File to edit: 00_datos.ipynb (unless otherwise specified).

__all__ = ['DATA_DIR_COVID', 'asegura_archivos_covid_disponibles', 'columnas_comunes', 'arregla_cvegeo',
           'carga_datos_covid19_MX', 'DATA_DIR_COVID', 'agrupa_casos_municipios', 'leer_variables_municipales',
           'unir_casos_estadisticas_municipales', 'tabla_covid_indicadores_municipales', 'municipios_urbanos']

# Cell
import os
import glob
import itertools
from fastcore.test import *

import pandas as pd
import geopandas as gpd
from osgeo import gdal, ogr
from datetime import timedelta
import csv

# Cell
DATA_DIR_COVID = 'datos/secretaria_salud/'


# Cell
def asegura_archivos_covid_disponibles(fechas):
    '''
    Esta función genera un error si no están disponibles todos los archivos de casos COVID-19 en México
    de las fechas especificadas. Los nombres de archivos siguen el patrón con el que los publica la Secretaría de Salud:
    {AÑO}{MES}{DIA}COVID19MEXICO.csv, por ejemplo 200413COVID19MEXICO.csv
    '''
    for fecha in fechas:
        fecha_str = fecha.strftime("%y%m%d")
        file = os.path.join(DATA_DIR_COVID, f'{fecha_str}COVID19MEXICO.csv')
        assert os.path.exists(file), f'{fecha_str} no disponible'


# Cell

def columnas_comunes(df_1, df_2):
    '''
    Obtiene la lista de columnas con el mismo nombre entre dos DataFrame
    '''
    return list(set(df_1.columns).intersection(df_2.columns))

# Cell

def arregla_cvegeo(df, campo_cvegeo='cvegeo', extraer_ent=False):
    '''
    Revisa que los indetificadores de municipio (clave entidad + clave municipio) tengan 5 digitos, si un identificador
    tiene 4 le agrega un cero. Esta corrección asume que el problema surgió de leer los identificadores como enteros
    lo cual provoca que se descarten los ceros a la izquierda.
    '''
    df[campo_cvegeo] = df[campo_cvegeo].apply(lambda x: '0' + x if len(x) == 4 else x)

    if extraer_ent:
        df[f'ent_{campo_cvegeo}'] = df[campo_cvegeo].str[:2]
    return df

# Cell
DATA_DIR_COVID = 'datos/secretaria_salud/'

def carga_datos_covid19_MX(fecha='200601', resolver_claves='si_no_binarias', periodo='dia'):
    """
        Lee en un DataFrame el CSV con el reporte de casos de la Secretaría de Salud de México publicado en una fecha dada. Esta función
        también lee el diccionario de datos que acompaña a estas publicaciones para preparar algunos campos, en particular permite la funcionalidad
        de generar columnas binarias para datos con valores 'SI', 'No'.

        **Nota**: En esta versión la ruta esta y nombre de los archivos es fija. Asumimos que existe un directorio 'datos/secretaria_salud/'
        donde se encuentran todos los archivos.

        periodo: 'dia', 'historico'. Trae los datos de la fecha indicada o trae
        la serie de conjuntos de datos hasta la fecha indicada (por implementar).

        resolver_claves: 'sustitucion', 'agregar', 'si_no_binarias', 'solo_localidades'. Resuelve los valores del conjunto de datos usando el
        diccionario de datos y los catálogos. 'sustitucion' remplaza los valores en las columnas, 'agregar'
        crea nuevas columnas. 'si_no_binarias' cambia valores SI, NO, No Aplica, SE IGNORA, NO ESPECIFICADO por 1, 0, 0, 0, 0 respectivamente.

    """

    file = os.path.join(DATA_DIR_COVID, f'{fecha}COVID19MEXICO.csv')
    df = pd.read_csv(file, dtype=object, encoding='latin-1')

    # Hay un error y el campo OTRA_COMP es OTRAS_COMP según los descriptores
    df.rename(columns={'OTRA_COM': 'OTRAS_COM'}, inplace=True)

    # Asignar clave única a municpios
    df['MUNICIPIO_RES'] = df['ENTIDAD_RES'] + df['MUNICIPIO_RES']
    df['CLAVE_MUNICIPIO_RES'] = df['MUNICIPIO_RES']

    # Resolver códigos de entidad federal
    entidades = pd.read_excel('datos/secretaria_salud/diccionario_datos_covid19/Catalogos_0412.xlsx',
                              'Catálogo de ENTIDADES',
                              dtype=str, encoding='latin-1')

    cols_entidad = ['ENTIDAD_RES', 'ENTIDAD_UM', 'ENTIDAD_NAC']
    df['CLAVE_ENTIDAD_RES'] = df['ENTIDAD_RES']
    df[cols_entidad] = df[cols_entidad].replace(to_replace=entidades['CLAVE_ENTIDAD'].values,
                                               value=entidades['ENTIDAD_FEDERATIVA'].values)

    # Leer diccionario y catálogo de datos
    municipios = pd.read_excel('datos/secretaria_salud/diccionario_datos_covid19/Catalogos_0412.xlsx',
                               'Catálogo MUNICIPIOS',
                               dtype=str)
    municipios['CLAVE_MUNICIPIO'] = municipios['CLAVE_ENTIDAD'] + municipios['CLAVE_MUNICIPIO']

    # Resolver códigos de municipio
    df['MUNICIPIO_RES'] = df['MUNICIPIO_RES'].replace(to_replace=municipios['CLAVE_MUNICIPIO'].values,
                                               value=municipios['MUNICIPIO'].values)

    # Resolver resultados
    tipo_resultado = pd.read_excel('datos/secretaria_salud/diccionario_datos_covid19/Catalogos_0412.xlsx',
                                   'Catálogo RESULTADO',
                                   dtype=str)
    df['RESULTADO'] = df['RESULTADO'].replace(to_replace=tipo_resultado['CLAVE'].values,
                                                              value=tipo_resultado['DESCRIPCIÓN'].values)

    # Resolver datos SI - NO

    # Necesitamos encontrar todos los campos que tienen este tipo de dato y eso
    # viene en los descriptores, en el campo FORMATO_O_FUENTE

    descriptores = pd.read_excel('datos/secretaria_salud/diccionario_datos_covid19/Descriptores_0419.xlsx',
                                 index_col='Nº')
    descriptores.columns = list(map(lambda col: col.replace(' ', '_'), descriptores.columns))
    descriptores['FORMATO_O_FUENTE'] = descriptores.FORMATO_O_FUENTE.str.strip()

    datos_si_no = descriptores.query('FORMATO_O_FUENTE == "CATÁLOGO: SI_ NO"')
    cat_si_no = pd.read_excel('datos/secretaria_salud/diccionario_datos_covid19/Catalogos_0412.xlsx',
                              'Catálogo SI_NO',
                              dtype=str)
    cat_si_no['DESCRIPCIÓN'] = cat_si_no['DESCRIPCIÓN'].str.strip()

    campos_si_no = datos_si_no.NOMBRE_DE_VARIABLE
    nuevos_campos_si_no = campos_si_no

    if resolver_claves == 'agregar':
        nuevos_campos_si_no = [nombre_var + '_NOM' for nombre_var in campos_si_no]
    elif resolver_claves == 'si_no_binarias':
        nuevos_campos_si_no = [nombre_var + '_BIN' for nombre_var in campos_si_no]
        cat_si_no['DESCRIPCIÓN'] = list(map(lambda val: 1 if val == 'SI' else 0, cat_si_no['DESCRIPCIÓN']))


    df[nuevos_campos_si_no] = df[datos_si_no.NOMBRE_DE_VARIABLE].replace(
                                                to_replace=cat_si_no['CLAVE'].values,
                                                value=cat_si_no['DESCRIPCIÓN'].values)
    # Resolver tipos de paciente
    cat_tipo_pac = pd.read_excel('datos/secretaria_salud/diccionario_datos_covid19/Catalogos_0412.xlsx',
                                 'Catálogo TIPO_PACIENTE',
                                 dtype=str)
    df['TIPO_PACIENTE'] = df['TIPO_PACIENTE'].replace(to_replace=cat_tipo_pac['CLAVE'].values,
                                                      value=cat_tipo_pac['DESCRIPCIÓN'].values)

    df['FECHA_INGRESO'] = pd.to_datetime(df['FECHA_INGRESO'])
    df['FECHA_SINTOMAS'] = pd.to_datetime(df['FECHA_SINTOMAS'])
    df['FECHA_DEF'] = pd.to_datetime(df['FECHA_DEF'], 'coerce')
    df['DEFUNCION'] = (df['FECHA_DEF'].notna()).astype(int)
    df['EDAD'] = df['EDAD'].astype(int)

    df.set_index('FECHA_INGRESO', inplace=True)
    df['AÑO_INGRESO'] = df.index.year
    df['MES_INGRESO'] = df.index.month
    df['DIA_SEMANA_INGRESO'] = df.index.weekday
    df['SEMANA_AÑO_INGRESO'] = df.index.weekofyear
    df['DIA_MES_INGRESO'] = df.index.day
    df['DIA_AÑO_INGRESO'] = df.index.dayofyear

    return df

# Cell

def agrupa_casos_municipios(casos_df):
    '''
        Este método crea una tabla con todos los municipios y el número de casos registrados
            para cada tipo de paciente y para cada resultado.
    '''
    casos_df = casos_df.copy()

    # cuenta número de casos por resultado
    marco_2019 = gpd.read_file('datos/municipios/marco_2019.json')
    marco_2019.rename(columns={'CVE_ENT': 'CLAVE_ENTIDAD_RES',
                               'municipio_cvegeo': 'CLAVE_MUNICIPIO_RES',
                               'municipio_nombre': 'MUNICIPIO_RES'}, inplace=True)
    marco_2019.MUNICIPIO_RES = marco_2019.MUNICIPIO_RES.str.upper()

    # poblacion_2020 = pd.read_csv('datos/municipios/proyeccion_poblacion_2020.csv',
    #                         dtype={'cve_ent': object, 'cve_mun': object, 'pob2020': int})

    if 'geometry' in casos_df.columns:
        casos_df.drop(columns='geometry', inplaace=True)

    claves_municipio = marco_2019.CLAVE_MUNICIPIO_RES.unique()
    tipos_resultado = casos_df.RESULTADO.unique()

    # claves_entidades = casos_df[['CLAVE_ENTIDAD_RES', 'ENTIDAD_RES']].drop_duplicates()

    # primero armamos la tabla de municipios y todos los tipos de casos, para luego llenar los conteos de cada tipo
    # para cada municipio
    tipos_caso_municipio = set(itertools.product(claves_municipio, tipos_resultado))
    tipos_caso_municipio = pd.DataFrame(tipos_caso_municipio, columns={'CLAVE_MUNICIPIO_RES': str, 'RESULTADO': str})

    # agregamos nombres y claves de entidad
    # poblacion_2020.rename(columns={'cve_ent': 'CLAVE_ENTIDAD_RES', 'cve_mun': 'CLAVE_MUNICIPIO_RES'}, inplace=True)
    tipos_caso_municipio = marco_2019.merge(tipos_caso_municipio, on=['CLAVE_MUNICIPIO_RES'], how='left')
    tipos_caso_municipio = tipos_caso_municipio.merge(casos_df[['CLAVE_ENTIDAD_RES', 'ENTIDAD_RES']].drop_duplicates(),
                                                      on=['CLAVE_ENTIDAD_RES'], how='left')

    # ahora contamos que ha pasado en cada municipio
    cols_localidad = ['ENTIDAD_RES', 'MUNICIPIO_RES', 'CLAVE_MUNICIPIO_RES']
    covid_municipal = casos_df[cols_localidad + ['RESULTADO', 'DEFUNCION']].groupby(cols_localidad + ['RESULTADO'])

    # claves_entidades = casos_df[['CLAVE_ENTIDAD_RES', 'ENTIDAD_RES']].drop_duplicates()

    covid_municipal = covid_municipal.agg({'RESULTADO':'count', 'DEFUNCION':sum})
    covid_municipal.rename(columns={'RESULTADO': 'conteo', 'DEFUNCION': 'defunciones'}, level=0, inplace=True)
    covid_municipal.reset_index(inplace=True)

    covid_municipal = covid_municipal.merge(marco_2019, on=['CLAVE_MUNICIPIO_RES', 'MUNICIPIO_RES'])

    covid_municipal = tipos_caso_municipio.merge(covid_municipal, on=list(tipos_caso_municipio.columns), how='left')
    covid_municipal[['conteo', 'defunciones']] = covid_municipal[['conteo', 'defunciones']].fillna(0)
    covid_municipal.drop(columns=['CVE_MUN'], inplace=True)
    return covid_municipal


# Cell

def leer_variables_municipales():
    variables_municipales = pd.read_csv('datos/municipios/indicadores.csv', index_col=False,
                                        dtype={'cvegeo': str, 'entidad_cv': str,
                                              'municipio_cvegeo': str, 'entidad_cvegeo': str},
                                        encoding='iso8859_2')
    arregla_cvegeo(variables_municipales, 'municipio_cvegeo')
    arregla_cvegeo(variables_municipales, extraer_ent=True)

    variables_municipales.drop(columns=['municipio_cvegeo', 'entidad_cv'], inplace=True)
    marco_2019 = gpd.read_file('datos/municipios/marco_2019.json')
    marco_2019.rename(columns={'municipio_cvegeo': 'cvegeo'}, inplace=True)
    # marco_2019 = marco_2019[['municipio_cvegeo', 'geometry', 'municipio_nombre']]
    variables_municipales = variables_municipales.merge(marco_2019, on='cvegeo')

    # variables_municipales.drop(columns='nom_mun', inplace=True)
    # variables_municipales.rename(columns={'municipio_nombre': 'nom_mun'}, inplace=True)
    return variables_municipales

# Cell
def unir_casos_estadisticas_municipales(casos_municipios_df, estats_municipios):
    cols_com = columnas_comunes(casos_municipios_df, estats_municipios)
    casos_municipios_df = casos_municipios_df.merge(estats_municipios,
                                      left_on=['CLAVE_MUNICIPIO_RES'] + cols_com,
                                      right_on=['cvegeo'] + cols_com, how='right')

    casos_municipios_df.drop(columns=['CVE_ENT', 'entidad_cvegeo', 'nom_mun', 'cvegeo',
                                      'nom_ent', 'municipio_nombre', 'id', 'ent_cvegeo', 'pob01'], inplace=True)

    return casos_municipios_df

# Cell

def tabla_covid_indicadores_municipales(fecha, solo_positivos=True):
    covid_df = carga_datos_covid19_MX(fecha)
    covid_mun_df = agrupa_casos_municipios(covid_df)
    mun_df = leer_variables_municipales()
    mun_df.drop(columns=['geometry'])
    covid_mun_df = unir_casos_estadisticas_municipales(covid_mun_df, mun_df)

    if solo_positivos:
        covid_mun_df = covid_mun_df[covid_mun_df.RESULTADO == 'Positivo SARS-CoV-2']
    return covid_mun_df


# Cell

def municipios_urbanos():
    archivo = 'datos/municipios/municipios_ciudades.csv'

    df = pd.read_csv(archivo, dtype=str)
    df.dropna(inplace=True)
    df.rename(columns={'municipio_cvegeo': "CLAVE_MUNICIPIO"}, inplace=True)
    return df